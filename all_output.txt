Assumptions:
1. The game board will be a 20x20 grid.
2. The snake will start at a speed of 1 block per second.
3. The snake will grow by 1 block each time it eats food.
4. The game will end when the snake hits the border or itself.
5. The score will be calculated based on the number of food items eaten.
6. The game will be text-based, with the snake represented by 'S', food by 'F', and empty spaces by '.'.
7. There will be no special items or power-ups.
8. There will be no high score system.

Core Classes, Functions, and Methods:
1. `Game`: This class will represent the game itself. It will contain methods to start the game, handle user input, update the game state, and check for game over conditions.
2. `Snake`: This class will represent the snake. It will contain methods to move the snake, grow the snake, and check if the snake has collided with itself.
3. `Food`: This class will represent the food. It will contain a method to place the food at a random location on the board.
4. `Board`: This class will represent the game board. It will contain methods to initialize the board, update the board, and display the board.

Now, let's write the code for each of these classes.

snake.py
```python
class Snake:
    def __init__(self):
        self.positions = [[5, 5]]
        self.direction = 'UP'

    def move(self):
        head = self.get_head_position()
        if self.direction == 'UP':
            self.positions.insert(0, [head[0], head[1] - 1])
        elif self.direction == 'DOWN':
            self.positions.insert(0, [head[0], head[1] + 1])
        elif self.direction == 'LEFT':
            self.positions.insert(0, [head[0] - 1, head[1]])
        elif self.direction == 'RIGHT':
            self.positions.insert(0, [head[0] + 1, head[1]])

    def grow(self):
        pass  # The snake grows by not removing the last element in self.positions

    def get_head_position(self):
        return self.positions[0]

    def collide_with_self(self):
        return self.get_head_position() in self.positions[1:]
```

food.py
```python
import random

class Food:
    def __init__(self):
        self.position = self.random_position()

    def random_position(self):
        return [random.randint(0, 19), random.randint(0, 19)]
```

board.py
```python
class Board:
    def __init__(self, snake, food):
        self.snake = snake
        self.food = food
        self.board = self.initialize_board()

    def initialize_board(self):
        board = [['.' for _ in range(20)] for _ in range(20)]
        for position in self.snake.positions:
            board[position[1]][position[0]] = 'S'
        board[self.food.position[1]][self.food.position[0]] = 'F'
        return board

    def update_board(self):
        self.board = self.initialize_board()

    def display_board(self):
        for row in self.board:
            print(' '.join(row))
```

game.py
```python
import time
from snake import Snake
from food import Food
from board import Board

class Game:
    def __init__(self):
        self.snake = Snake()
        self.food = Food()
        self.board = Board(self.snake, self.food)
        self.score = 0

    def start(self):
        while True:
            self.board.display_board()
            time.sleep(1)
            self.snake.move()
            if self.snake.get_head_position() == self.food.position:
                self.snake.grow()
                self.score += 1
                self.food = Food()
            self.board.update_board()
            if self.game_over():
                break
        print(f'Game Over! Your score is: {self.score}')

    def game_over(self):
        head = self.snake.get_head_position()
        return (head[0] < 0 or head[0] >= 20 or head[1] < 0 or head[1] >= 20 or self.snake.collide_with_self())
```

main.py
```python
from game import Game

if __name__ == '__main__':
    game = Game()
    game.start()
```

requirements.txt
```txt
python==3.8.5
```

Please note that this is a simple implementation of the snake game. It does not handle user input to change the direction of the snake. You can add this functionality by using a library like `curses` to handle real-time keyboard input.
Given the complexity of creating a game like Candy Crush, it's not feasible to provide a full implementation in this format. However, I can provide a simplified Python version of a match-three game. This version will not include graphics or user interfaces, and will be played in the console.

Here are the core classes and functions:

1. `Game`: This class will represent the game itself. It will contain the game board and game logic.
   - `__init__`: Initializes a new game.
   - `create_board`: Creates a new game board.
   - `draw_board`: Prints the current game board to the console.
   - `swap`: Swaps two candies on the board.
   - `find_matches`: Finds all matches on the board.
   - `remove_matches`: Removes matches from the board and drops candies down.
   - `fill_board`: Fills the board with new candies after matches are removed.
   - `play`: Starts the game loop.

2. `Candy`: This class will represent a candy on the game board.
   - `__init__`: Initializes a new candy with a random type.

Now, let's write the code for these classes and functions.

game.py
```python
import random

class Game:
    def __init__(self, size=8):
        self.size = size
        self.board = self.create_board()

    def create_board(self):
        return [[Candy() for _ in range(self.size)] for _ in range(self.size)]

    def draw_board(self):
        for row in self.board:
            print(' '.join(str(candy) for candy in row))
        print()

    def swap(self, pos1, pos2):
        self.board[pos1[0]][pos1[1]], self.board[pos2[0]][pos2[1]] = self.board[pos2[0]][pos2[1]], self.board[pos1[0]][pos1[1]]

    def find_matches(self):
        # This is a simplified version of match finding. It only checks for matches in rows.
        matches = []
        for row in self.board:
            for i in range(self.size - 2):
                if row[i] == row[i+1] == row[i+2]:
                    matches.append((row[i], row[i+1], row[i+2]))
        return matches

    def remove_matches(self, matches):
        for match in matches:
            for candy in match:
                self.board[candy.row][candy.col] = None

    def fill_board(self):
        for row in range(self.size):
            for col in range(self.size):
                if self.board[row][col] is None:
                    self.board[row][col] = Candy()

    def play(self):
        while True:
            self.draw_board()
            pos1 = input("Enter the position of the first candy to swap (row col): ")
            pos2 = input("Enter the position of the second candy to swap (row col): ")
            self.swap(pos1, pos2)
            matches = self.find_matches()
            self.remove_matches(matches)
            self.fill_board()

class Candy:
    def __init__(self):
        self.type = random.choice(['red', 'blue', 'green', 'yellow'])

    def __str__(self):
        return self.type[0]
```

requirements.txt
```plaintext
python==3.8.5
```

To play the game, you would run the `game.py` script and follow the prompts in the console. This is a very simplified version of Candy Crush and doesn't include many of the features of the full game, such as special candies, obstacles, or level goals. However, it does demonstrate the basic game loop and mechanics of a match-three game.
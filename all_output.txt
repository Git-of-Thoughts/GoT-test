The core classes, functions, and methods necessary for this game are:

1. `Game` class: This will be the main class that controls the game loop, user input, and game over conditions.
2. `Snake` class: This class will represent the snake. It will have methods to move the snake, grow the snake, and check if the snake has collided with itself.
3. `Fruit` class: This class will represent the fruit. It will have a method to place the fruit at a random location on the board.
4. `Board` class: This class will represent the game board. It will have methods to initialize the board, update the board, and print the board.

Now, let's write the code for each of these classes.

snake.py
```python
class Snake:
    def __init__(self):
        self.positions = [[5, 5]]
        self.direction = 'U'

    def move(self):
        head = self.get_head_position()
        if self.direction == 'U':
            self.positions.insert(0, [head[0]-1, head[1]])
        elif self.direction == 'D':
            self.positions.insert(0, [head[0]+1, head[1]])
        elif self.direction == 'L':
            self.positions.insert(0, [head[0], head[1]-1])
        elif self.direction == 'R':
            self.positions.insert(0, [head[0], head[1]+1])
        self.positions.pop()

    def grow(self):
        head = self.get_head_position()
        if self.direction == 'U':
            self.positions.insert(0, [head[0]-1, head[1]])
        elif self.direction == 'D':
            self.positions.insert(0, [head[0]+1, head[1]])
        elif self.direction == 'L':
            self.positions.insert(0, [head[0], head[1]-1])
        elif self.direction == 'R':
            self.positions.insert(0, [head[0], head[1]+1])

    def get_head_position(self):
        return self.positions[0]

    def collide_with_self(self):
        return self.get_head_position() in self.positions[1:]
```

fruit.py
```python
import random

class Fruit:
    def __init__(self):
        self.position = [random.randint(0, 19), random.randint(0, 19)]

    def place(self):
        self.position = [random.randint(0, 19), random.randint(0, 19)]
```

board.py
```python
class Board:
    def __init__(self, snake, fruit):
        self.snake = snake
        self.fruit = fruit
        self.board = [[' ' for _ in range(20)] for _ in range(20)]

    def update(self):
        self.board = [[' ' for _ in range(20)] for _ in range(20)]
        for position in self.snake.positions:
            self.board[position[0]][position[1]] = 'S'
        self.board[self.fruit.position[0]][self.fruit.position[1]] = 'F'

    def print(self):
        for row in self.board:
            print(''.join(row))
```

game.py
```python
import time
from snake import Snake
from fruit import Fruit
from board import Board

class Game:
    def __init__(self):
        self.snake = Snake()
        self.fruit = Fruit()
        self.board = Board(self.snake, self.fruit)
        self.score = 0

    def run(self):
        while True:
            self.board.update()
            self.board.print()
            time.sleep(0.1)
            self.snake.move()
            if self.snake.get_head_position() == self.fruit.position:
                self.snake.grow()
                self.fruit.place()
                self.score += 1
            if self.snake.collide_with_self():
                break
        print(f'Game Over! Your score is: {self.score}')

if __name__ == "__main__":
    game = Game()
    game.run()
```

requirements.txt
```txt
python==3.8.5
```

Please note that this is a simple implementation of the snake game. It does not handle user input to change the direction of the snake, and the game speed does not increase as the game progresses. These features could be added with additional code.
The core classes, functions, and methods necessary for the snake game are:

1. `main.go`: This is the entry point of the application. It contains the main function which initializes the game and starts the game loop.

2. `game.go`: This file contains the Game struct and its methods. The Game struct holds the state of the game, including the snake, the food, and the score. The methods in this file handle the game logic, such as updating the game state and checking for game over conditions.

3. `snake.go`: This file contains the Snake struct and its methods. The Snake struct represents the snake in the game. The methods in this file handle the movement and growth of the snake.

4. `food.go`: This file contains the Food struct and its methods. The Food struct represents the food in the game. The methods in this file handle the placement of the food.

5. `utils.go`: This file contains utility functions for the game, such as functions for generating random numbers.

Now, let's write the code for each file.

main.go
```go
package main

import (
	"fmt"
	"time"
)

func main() {
	game := NewGame()
	for !game.GameOver {
		game.Update()
		fmt.Println(game.Render())
		time.Sleep(time.Second / 10)
	}
	fmt.Println("Game over!")
}
```

game.go
```go
package main

type Game struct {
	Snake   *Snake
	Food    *Food
	Score   int
	GameOver bool
}

func NewGame() *Game {
	return &Game{
		Snake:   NewSnake(),
		Food:    NewFood(),
		Score:   0,
		GameOver: false,
	}
}

func (g *Game) Update() {
	if g.Snake.CollidesWith(g.Food) {
		g.Score++
		g.Food = NewFood()
		g.Snake.Grow()
	}
	if g.Snake.CollidesWithSelf() {
		g.GameOver = true
	}
	g.Snake.Move()
}

func (g *Game) Render() string {
	// Render the game state as a string
}
```

snake.go
```go
package main

type Snake struct {
	Body []Point
	Dir  Direction
}

func NewSnake() *Snake {
	return &Snake{
		Body: []Point{{5, 5}},
		Dir:  Right,
	}
}

func (s *Snake) Move() {
	// Move the snake in the current direction
}

func (s *Snake) Grow() {
	// Add a new segment to the snake's body
}

func (s *Snake) CollidesWith(p Point) bool {
	// Check if the snake collides with the given point
}

func (s *Snake) CollidesWithSelf() bool {
	// Check if the snake collides with itself
}
```

food.go
```go
package main

type Food struct {
	Pos Point
}

func NewFood() *Food {
	return &Food{
		Pos: RandomPoint(),
	}
}
```

utils.go
```go
package main

import (
	"math/rand"
	"time"
)

func RandomPoint() Point {
	rand.Seed(time.Now().UnixNano())
	return Point{rand.Intn(10), rand.Intn(10)}
}
```

Please note that the `Render` method in `game.go` and the `Move` and `Grow` methods in `snake.go` are not fully implemented. These methods depend on how you want to render the game and how you want the snake to move and grow.
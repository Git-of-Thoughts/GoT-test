Based on the assumptions, we will be using Python with Flask for the backend and SQLite for the database. The core classes and functions will be:

1. `Customer`: A class to represent a customer. It will have attributes such as `id`, `name`, `email`, `phone`, and `address`.
2. `Interaction`: A class to represent an interaction with a customer. It will have attributes such as `id`, `customer_id`, `date`, `notes`.
3. `app.py`: The entry point of the application. It will contain the routes for the web application.
4. `database.py`: This file will contain the functions to interact with the database, such as `get_customer`, `add_customer`, `update_customer`, `delete_customer`, `get_interaction`, `add_interaction`, `update_interaction`, `delete_interaction`.

Now, let's start with the `app.py` file:

app.py
```python
from flask import Flask, request, jsonify
from database import get_customer, add_customer, update_customer, delete_customer, get_interaction, add_interaction, update_interaction, delete_interaction

app = Flask(__name__)

@app.route('/customer', methods=['GET', 'POST'])
def customer():
    if request.method == 'GET':
        return jsonify(get_customer(request.args.get('id')))
    elif request.method == 'POST':
        return jsonify(add_customer(request.json))

@app.route('/customer/<id>', methods=['PUT', 'DELETE'])
def customer_id(id):
    if request.method == 'PUT':
        return jsonify(update_customer(id, request.json))
    elif request.method == 'DELETE':
        return jsonify(delete_customer(id))

@app.route('/interaction', methods=['GET', 'POST'])
def interaction():
    if request.method == 'GET':
        return jsonify(get_interaction(request.args.get('id')))
    elif request.method == 'POST':
        return jsonify(add_interaction(request.json))

@app.route('/interaction/<id>', methods=['PUT', 'DELETE'])
def interaction_id(id):
    if request.method == 'PUT':
        return jsonify(update_interaction(id, request.json))
    elif request.method == 'DELETE':
        return jsonify(delete_interaction(id))

if __name__ == '__main__':
    app.run(debug=True)
```

Next, let's move on to the `database.py` file:

database.py
```python
import sqlite3
from sqlite3 import Error

def create_connection():
    conn = None;
    try:
        conn = sqlite3.connect(':memory:') # create a database connection to a SQLite database in memory
        return conn
    except Error as e:
        print(e)

def get_customer(id):
    conn = create_connection()
    cur = conn.cursor()
    cur.execute("SELECT * FROM customers WHERE id=?", (id,))
    rows = cur.fetchall()
    return rows

def add_customer(customer):
    conn = create_connection()
    cur = conn.cursor()
    cur.execute("INSERT INTO customers(name,email,phone,address) VALUES(?,?,?,?)", (customer['name'], customer['email'], customer['phone'], customer['address']))
    conn.commit()
    return cur.lastrowid

def update_customer(id, customer):
    conn = create_connection()
    cur = conn.cursor()
    cur.execute("UPDATE customers SET name=?, email=?, phone=?, address=? WHERE id=?", (customer['name'], customer['email'], customer['phone'], customer['address'], id))
    conn.commit()
    return cur.rowcount

def delete_customer(id):
    conn = create_connection()
    cur = conn.cursor()
    cur.execute("DELETE FROM customers WHERE id=?", (id,))
    conn.commit()
    return cur.rowcount

def get_interaction(id):
    conn = create_connection()
    cur = conn.cursor()
    cur.execute("SELECT * FROM interactions WHERE id=?", (id,))
    rows = cur.fetchall()
    return rows

def add_interaction(interaction):
    conn = create_connection()
    cur = conn.cursor()
    cur.execute("INSERT INTO interactions(customer_id,date,notes) VALUES(?,?,?)", (interaction['customer_id'], interaction['date'], interaction['notes']))
    conn.commit()
    return cur.lastrowid

def update_interaction(id, interaction):
    conn = create_connection()
    cur = conn.cursor()
    cur.execute("UPDATE interactions SET customer_id=?, date=?, notes=? WHERE id=?", (interaction['customer_id'], interaction['date'], interaction['notes'], id))
    conn.commit()
    return cur.rowcount

def delete_interaction(id):
    conn = create_connection()
    cur = conn.cursor()
    cur.execute("DELETE FROM interactions WHERE id=?", (id,))
    conn.commit()
    return cur.rowcount
```

Finally, we need to create a `requirements.txt` file to list all the Python packages that need to be installed:

requirements.txt
```
Flask==1.1.2
sqlite3==2.6.0
```

This is a basic implementation of a CRM system. It can be extended with more features such as user authentication, data validation, error handling, and a frontend interface.